#使用枚举规则的方式实现
## 问题分析
分析问题的需求，发现规则，
1. 当整数x除以3的余数为0时输出fizz
2. 当整数x除以5的余数为0时输出buzz
3. 当整数除以15（3×5）为0时输出fizzbuzz
4. 其他情况下输出x本身
根据上面的规则对输入的x进行逐一判断，实现如rule_base.py中所示的代码
## 需求扩展
考虑扩展一下问题，增加一个数字7,那么问题的规则会更加4条：
1. 当整数x除以7的余数为0时输出gezz
2. 当整数除以21（3×7）的余数为0时输出fizzgezz
3. 当整数除以35（5×7）的余数为0时输出buzzgezz
4. 当整数除以85（3×5×7）的余数为0时输出fizzbuzzgezz。
可以发现，如此扩展下去规则会越来越多。再考虑到扩展的规则可能与原来已有的规则不存在相似性，那么问题的逻辑会变得越来越复杂。而实际生产中往往就是这样的。


#使用AI的方式实现
## 问题分析
已经分析除了问题的规则，根据规则可以构建除特征向量：
    **[x%3,x%5]**
再将输出结果映射成数字
    [3] 代表输出fizzbuzz
    [2] 代表输出buzz
    [1] 代表输出fizz
    [0] 代表输出x本身

然后取若干1～100以外的其他整数构建训练集，对线性回归模型进行训练。
使用1～100的整数构建测试集对训练得到的分类器进行测试
计算预测值和真实值之间的均方误差为0.38，这说明并不是完全准确。

## 需求扩展
增加一个数字7,特征向量变成：
    **[x%3,x%5,x%7]**
建立真值映射规则：
    [7] 代表被3、5和7整除
    [6] 代表被5和7整除
    [5] 代表被3和7整除
    [4] 代表被3和5整除
    [3] 代表被7整除
    [2] 代表被5整除
    [1] 代表被3整除
    [0] 代表输出x本身
最后得到的均方误差为1.43

## 尝试修改特征构建方法
经过降维，将低余数值的复杂度，得到特征向量
**[
    1 if i % 3 == 0 else 0,
    1 if i % 5 == 0 else 0,
]**
训练后得到的均方误差为0.00，

规则扩展后的特征向量为
**[
    1 if i % 3 == 0 else 0,
    1 if i % 5 == 0 else 0,
]**
训练后得到的均方误差为0.05

## 更多的特征构建方法的实验
特征构建方法的实验以及结果在文件fizz_buzz_lr_experiment.py中

#对比两种方式
对于这个例子来说显然基于规则的实现更合适，因为它精准。
而AI方式的实现总会存在误差。
但是如果在实际当中使用机器进行一些需要分析各方面因素，通过专业经验做判断、决策、预测时，显然AI的实现方式更加适合。
两种实现方式，各有各的应用场景。